export const questions = [
  {
    question: "Which of the following is NOT a core principle of Object-Oriented Programming (OOP)?",
    options: [
      "Inheritance",
      "Compilation",
      "Polymorphism",
      "Encapsulation"
    ],
    correctOption: "Compilation",
    difficulty: "beginner"
  },
  {
    question: "What is the primary purpose of a class in OOP?",
    options: [
      "To create objects",
      "To define a data type",
      "To control program flow",
      "To manage memory"
    ],
    correctOption: "To define a data type",
    difficulty: "beginner"
  },
  {
    question: "An object is an instance of a:",
    options: [
      "Method",
      "Attribute",
      "Class",
      "Function"
    ],
    correctOption: "Class",
    difficulty: "beginner"
  },
  {
    question: "Which OOP principle allows an object to take on many forms?",
    options: [
      "Polymorphism",
      "Inheritance",
      "Encapsulation",
      "Abstraction"
    ],
    correctOption: "Polymorphism",
    difficulty: "beginner"
  },
  {
    question: "What is the term for hiding the internal details of an object from the outside world?",
    options: [
      "Abstraction",
      "Inheritance",
      "Polymorphism",
      "Encapsulation"
    ],
    correctOption: "Encapsulation",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is a mechanism of reusing code by creating new classes from existing ones?",
    options: [
      "Abstraction",
      "Encapsulation",
      "Polymorphism",
      "Inheritance"
    ],
    correctOption: "Inheritance",
    difficulty: "beginner"
  },
  {
    question: "What is the process of simplifying complex reality by modeling classes appropriate to the problem?",
    options: [
      "Abstraction",
      "Inheritance",
      "Encapsulation",
      "Polymorphism"
    ],
    correctOption: "Abstraction",
    difficulty: "beginner"
  },
  {
    question: "In OOP, methods define the _________ of an object.",
    options: [
      "Behavior",
      "Attributes",
      "Identity",
      "State"
    ],
    correctOption: "Behavior",
    difficulty: "beginner"
  },
  {
    question: "Which of the following access modifiers is the most restrictive?",
    options: [
      "Internal",
      "Public",
      "Private",
      "Protected"
    ],
    correctOption: "Private",
    difficulty: "beginner"
  },
  {
    question: "A constructor is a special method used to:",
    options: [
      "Access private members",
      "Define class behavior",
      "Initialize objects",
      "Destroy objects"
    ],
    correctOption: "Initialize objects",
    difficulty: "beginner"
  },
  {
    question: "Which type of inheritance is NOT directly supported by C++?",
    options: [
      "Hybrid",
      "Multiple",
      "Single",
      "Hierarchical"
    ],
    correctOption: "Multiple",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of a virtual function in C++?",
    options: [
      "To create objects",
      "To implement polymorphism",
      "To access private members",
      "To define a class"
    ],
    correctOption: "To implement polymorphism",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about abstract classes?",
    options: [
      "They can be instantiated",
      "They can have only static members",
      "They cannot have concrete methods",
      "They cannot be inherited"
    ],
    correctOption: "They cannot be instantiated",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between method overloading and method overriding?",
    options: [
      "Overloading is static, overriding is dynamic",
      "Overloading is dynamic, overriding is static",
      "Overloading is in different classes, overriding is in the same class",
      "Overloading is in the same class, overriding is in different classes"
    ],
    correctOption: "Overloading is in the same class, overriding is in different classes",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable?",
    options: [
      "Observer",
      "Singleton",
      "Factory",
      "Strategy"
    ],
    correctOption: "Strategy",
    difficulty: "intermediate"
  },
  {
    question: "What is the primary goal of the SOLID principles?",
    options: [
      "To manage databases",
      "To design user interfaces",
      "To write efficient code",
      "To create maintainable and scalable software"
    ],
    correctOption: "To create maintainable and scalable software",
    difficulty: "intermediate"
  },
  {
    question: "Which SOLID principle states that a class should have only one reason to change?",
    options: [
      "Interface Segregation Principle",
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Liskov Substitution Principle"
    ],
    correctOption: "Single Responsibility Principle",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to create objects without exposing the instantiation logic to the client?",
    options: [
      "Observer",
      "Strategy",
      "Singleton",
      "Factory"
    ],
    correctOption: "Factory",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'protected' access modifier?",
    options: [
      "Accessible only within the package",
      "Accessible only within the class",
      "Accessible within the class and its subclasses",
      "Accessible from anywhere"
    ],
    correctOption: "Accessible within the class and its subclasses",
    difficulty: "intermediate"
  },
  {
    question: "What is a pure virtual function?",
    options: [
      "A function with no return value",
      "A virtual function that is not defined",
      "A function that cannot be inherited",
      "A function that is always overridden"
    ],
    correctOption: "A virtual function that is not defined",
    difficulty: "intermediate"
  },
  {
    question: "What is the diamond problem in multiple inheritance?",
    options: [
      "A problem with memory allocation",
      "A problem with ambiguity in inheriting from multiple classes",
      "A problem with constructor overloading",
      "A problem with virtual function calls"
    ],
    correctOption: "A problem with ambiguity in inheriting from multiple classes",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern aims to reduce coupling between objects by defining a higher-level interface?",
    options: [
      "Adapter",
      "Decorator",
      "Facade",
      "Bridge"
    ],
    correctOption: "Facade",
    difficulty: "beginner"
  },
  {
    question: "What is the difference between composition and inheritance?",
    options: [
      "Composition is dynamic, inheritance is static",
      "Composition is a 'is-a' relationship, inheritance is a 'has-a' relationship",
      "Composition is static, inheritance is dynamic",
      "Composition is a 'has-a' relationship, inheritance is a 'is-a' relationship"
    ],
    correctOption: "Composition is a 'has-a' relationship, inheritance is a 'is-a' relationship",
    difficulty: "beginner"
  },
  {
    question: "Which SOLID principle suggests that you should be able to substitute objects of a superclass with objects of a subclass without affecting the correctness of the program?",
    options: [
      "Single Responsibility Principle",
      "Open/Closed Principle",
      "Liskov Substitution Principle",
      "Interface Segregation Principle"
    ],
    correctOption: "Liskov Substitution Principle",
    difficulty: "advanced"
  },
  {
    question: "What is the role of an interface in OOP?",
    options: [
      "To manage memory",
      "To define a class",
      "To specify a contract for classes to implement",
      "To create objects"
    ],
    correctOption: "To specify a contract for classes to implement",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to dynamically add responsibilities to an object without altering its class?",
    options: [
      "Facade",
      "Decorator",
      "Adapter",
      "Bridge"
    ],
    correctOption: "Decorator",
    difficulty: "advanced"
  },
  {
    question: "What is the main advantage of using design patterns?",
    options: [
      "They reduce memory usage",
      "They make code shorter",
      "They improve code readability and reusability",
      "They increase program execution speed"
    ],
    correctOption: "They improve code readability and reusability",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'final' keyword in Java?",
    options: [
      "To define a constant variable",
      "All of the above",
      "To prevent a class from being inherited",
      "To prevent a method from being overridden"
    ],
    correctOption: "All of the above",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between shallow copy and deep copy?",
    options: [
      "Shallow copy creates a new object and copies values, deep copy creates a new object and copies references",
      "There is no difference between them",
      "Shallow copy copies only primitive types, deep copy copies all types",
      "Shallow copy creates a new object and copies references, deep copy creates a new object and copies values"
    ],
    correctOption: "Shallow copy creates a new object and copies references, deep copy creates a new object and copies values",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is NOT a type of polymorphism?",
    options: [
      "Subtype Polymorphism",
      "Ad hoc Polymorphism",
      "Parametric Polymorphism",
      "Compilation Polymorphism"
    ],
    correctOption: "Compilation Polymorphism",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of using inheritance?",
    options: [
      "Reduced code reusability",
      "Code reusability and reduced redundancy",
      "Increased code complexity",
      "Improved data security"
    ],
    correctOption: "Code reusability and reduced redundancy",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is a valid example of a class in Java?",
    options: [
      "public void myMethod() {}",
      "public class MyClass {}",
      "MyClass myObject = new MyClass();",
      "String myVariable;"
    ],
    correctOption: "public class MyClass {}",
    difficulty: "beginner"
  },
  {
    question: "What does the 'new' keyword do in Java?",
    options: [
      "Declares a new variable",
      "Defines a new method",
      "Imports a new package",
      "Creates a new object"
    ],
    correctOption: "Creates a new object",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is a valid method signature in Java?",
    options: [
      "public static void myFunction()",
      "myFunction()",
      "myFunction: void",
      "void myFunction"
    ],
    correctOption: "public static void myFunction()",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\nclass MyClass {\n  int x = 10;\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    MyClass myObj = new MyClass();\n    System.out.println(myObj.x);\n  }\n}",
    options: [
      "0",
      "Null",
      "10",
      "Error"
    ],
    correctOption: "10",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is NOT a valid access modifier in Java?",
    options: [
      "private",
      "protected",
      "friend",
      "public"
    ],
    correctOption: "friend",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'this' keyword in Java?",
    options: [
      "To call a static method",
      "To define a new variable",
      "To refer to the current object",
      "To refer to the superclass"
    ],
    correctOption: "To refer to the current object",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is a valid constructor in Java?",
    options: [
      "public void MyClass() {}",
      "static MyClass() {}",
      "MyClass(int x) {}",
      "void MyClass() {}"
    ],
    correctOption: "MyClass(int x) {}",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\nclass Base {\n  public void display() {\n    System.out.println(\"Base\");\n  }\n}\n\nclass Derived extends Base {\n  public void display() {\n    System.out.println(\"Derived\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Base obj = new Derived();\n    obj.display();\n  }\n}",
    options: [
      "Derived",
      "Base",
      "Error",
      "Null"
    ],
    correctOption: "Derived",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about interfaces in Java?",
    options: [
      "They can be implemented by classes",
      "They can have concrete methods",
      "They can be instantiated",
      "They can have only static members"
    ],
    correctOption: "They can be implemented by classes",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between an abstract class and an interface in Java?",
    options: [
      "There is no difference between them",
      "Abstract classes can have concrete methods, interfaces cannot",
      "Abstract classes can be instantiated, interfaces cannot",
      "Interfaces can have concrete methods, abstract classes cannot"
    ],
    correctOption: "Abstract classes can have concrete methods, interfaces cannot",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to implement an interface in Java?",
    options: [
      "interface MyInterface extends MyClass {}",
      "interface MyInterface implements MyClass {}",
      "class MyClass inherits MyInterface {}",
      "class MyClass implements MyInterface {}"
    ],
    correctOption: "class MyClass implements MyInterface {}",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\ninterface MyInterface {\n  void display();\n}\n\nclass MyClass implements MyInterface {\n  public void display() {\n    System.out.println(\"Hello\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    MyClass obj = new MyClass();\n    obj.display();\n  }\n}",
    options: [
      "Hello",
      "MyInterface",
      "Error",
      "Null"
    ],
    correctOption: "Hello",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid example of method overloading in Java?",
    options: [
      "Both A and B",
      "public void myMethod(int x) {}",
      "public void myMethod(int x, int y) {}",
      "public int myMethod(int x) {}"
    ],
    correctOption: "Both A and B",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'super' keyword in Java?",
    options: [
      "To refer to the current object",
      "To define a new variable",
      "To call a static method",
      "To refer to the superclass"
    ],
    correctOption: "To refer to the superclass",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\nclass Parent {\n  public Parent() {\n    System.out.println(\"Parent Constructor\");\n  }\n}\n\nclass Child extends Parent {\n  public Child() {\n    System.out.println(\"Child Constructor\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Child obj = new Child();\n  }\n}",
    options: [
      "Child Constructor\\nParent Constructor",
      "Child Constructor",
      "Parent Constructor\\nChild Constructor",
      "Parent Constructor"
    ],
    correctOption: "Parent Constructor\nChild Constructor",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to prevent a method from being overridden in Java?",
    options: [
      "Using the 'static' keyword",
      "Using the 'final' keyword",
      "Using the 'private' keyword",
      "Using the 'abstract' keyword"
    ],
    correctOption: "Using the 'final' keyword",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between checked and unchecked exceptions in Java?",
    options: [
      "Checked exceptions are handled at compile time, unchecked exceptions are handled at runtime",
      "Unchecked exceptions are handled at compile time, checked exceptions are handled at runtime",
      "There is no difference between them",
      "Checked exceptions are subclasses of Error, unchecked exceptions are subclasses of Exception"
    ],
    correctOption: "Checked exceptions are handled at compile time, unchecked exceptions are handled at runtime",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern defines the skeleton of an algorithm in the superclass but lets subclasses redefine certain steps of the algorithm without changing the algorithm's structure?",
    options: [
      "Strategy",
      "Factory",
      "Observer",
      "Template Method"
    ],
    correctOption: "Template Method",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'volatile' keyword in Java?",
    options: [
      "To prevent a method from being overridden",
      "To prevent a variable from being garbage collected",
      "To ensure that a variable is read from and written to main memory",
      "To define a constant variable"
    ],
    correctOption: "To ensure that a variable is read from and written to main memory",
    difficulty: "advanced"
  },
  {
    question: "What is the difference between the '==' operator and the 'equals()' method in Java?",
    options: [
      "'==' can be used for primitive types only, 'equals()' can be used for objects only",
      "There is no difference between them",
      "'==' compares object references, 'equals()' compares object values",
      "'==' compares object values, 'equals()' compares object references"
    ],
    correctOption: "'==' compares object references, 'equals()' compares object values",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to create a thread in Java?",
    options: [
      "Both A and B",
      "Implementing the Runnable interface",
      "Extending the Thread class",
      "Using the 'thread' keyword"
    ],
    correctOption: "Both A and B",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'synchronized' keyword in Java?",
    options: [
      "To ensure that only one thread can access a method or block of code at a time",
      "To prevent a method from being overridden",
      "To define a constant variable",
      "To prevent a variable from being garbage collected"
    ],
    correctOption: "To ensure that only one thread can access a method or block of code at a time",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between the 'throw' and 'throws' keywords in Java?",
    options: [
      "'throws' is used to declare an exception, 'throw' is used to throw an exception",
      "'throw' is used for checked exceptions, 'throws' is used for unchecked exceptions",
      "'throw' is used to declare an exception, 'throws' is used to throw an exception",
      "There is no difference between them"
    ],
    correctOption: "'throws' is used to declare an exception, 'throw' is used to throw an exception",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is a valid example of method overriding in Java?",
    options: [
      "class Parent { public void display() {} } class Child extends Parent { private void display() {} }",
      "class Parent { public void display() {} } class Child extends Parent { public void display() {} }",
      "class Parent { public void display() {} } class Child extends Parent { public void display(int x) {} }",
      "class Parent { public void display() {} } class Child extends Parent { public int display() {} }"
    ],
    correctOption: "class Parent { public void display() {} } class Child extends Parent { public void display() {} }",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\nclass MyClass {\n  static int count = 0;\n  public MyClass() {\n    count++;\n  }\n  public static int getCount() {\n    return count;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    MyClass obj1 = new MyClass();\n    MyClass obj2 = new MyClass();\n    System.out.println(MyClass.getCount());\n  }\n}",
    options: [
      "1",
      "0",
      "2",
      "Error"
    ],
    correctOption: "2",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to provide a unified interface to a set of interfaces in a subsystem?",
    options: [
      "Facade",
      "Decorator",
      "Adapter",
      "Bridge"
    ],
    correctOption: "Facade",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of garbage collection in Java?",
    options: [
      "To allocate memory to objects",
      "To handle exceptions",
      "To free up memory occupied by unused objects",
      "To manage file input/output"
    ],
    correctOption: "To free up memory occupied by unused objects",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to declare a constant variable in Java?",
    options: [
      "public int x = 10;",
      "static int x = 10;",
      "const int x = 10;",
      "final int x = 10;"
    ],
    correctOption: "final int x = 10;",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\npublic class Main {\n  public static void main(String[] args) {\n    String str1 = \"Hello\";\n    String str2 = new String(\"Hello\");\n    System.out.println(str1.equals(str2));\n  }\n}",
    options: [
      "Null",
      "false",
      "true",
      "Error"
    ],
    correctOption: "true",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about static methods in Java?",
    options: [
      "They can access non-static members",
      "They can be overridden",
      "They can be called without creating an object of the class",
      "They can be declared in interfaces"
    ],
    correctOption: "They can be called without creating an object of the class",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'finally' block in a try-catch statement in Java?",
    options: [
      "To handle exceptions",
      "To specify code that is always executed, regardless of whether an exception is thrown",
      "To define a new variable",
      "To call a static method"
    ],
    correctOption: "To specify code that is always executed, regardless of whether an exception is thrown",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to throw an exception in Java?",
    options: [
      "new throw Exception();",
      "throw Exception;",
      "throw new Exception();",
      "catch new Exception();"
    ],
    correctOption: "throw new Exception();",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\npublic class Main {\n  public static void main(String[] args) {\n    try {\n      int x = 10 / 0;\n    } catch (ArithmeticException e) {\n      System.out.println(\"Arithmetic Exception\");\n    } finally {\n      System.out.println(\"Finally Block\");\n    }\n  }\n}",
    options: [
      "Arithmetic Exception\\nFinally Block",
      "Arithmetic Exception",
      "Finally Block",
      "Error"
    ],
    correctOption: "Arithmetic Exception\nFinally Block",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to handle multiple exceptions in Java?",
    options: [
      "try { ... } catch (Exception1 | Exception2 e) { ... }",
      "Both A and B",
      "try { ... } catch (Exception1 e1) { ... } catch (Exception2 e2) { ... }",
      "try { ... } catch (Exception1 e1, Exception2 e2) { ... }"
    ],
    correctOption: "Both A and B",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'instanceof' operator in Java?",
    options: [
      "To call a static method",
      "To check if an object is an instance of a class or interface",
      "To create a new object",
      "To define a new variable"
    ],
    correctOption: "To check if an object is an instance of a class or interface",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\nclass Parent {}\nclass Child extends Parent {}\n\npublic class Main {\n  public static void main(String[] args) {\n    Parent obj = new Child();\n    System.out.println(obj instanceof Child);\n  }\n}",
    options: [
      "Error",
      "true",
      "false",
      "Null"
    ],
    correctOption: "true",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to create an anonymous class in Java?",
    options: [
      "new MyClass() {}",
      "new MyClass() extends {}",
      "class MyClass extends new MyClass() {}",
      "new class MyClass() {}"
    ],
    correctOption: "new MyClass() {}",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'transient' keyword in Java?",
    options: [
      "To prevent a variable from being garbage collected",
      "To define a constant variable",
      "To indicate that a variable should not be serialized",
      "To prevent a method from being overridden"
    ],
    correctOption: "To indicate that a variable should not be serialized",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between serialization and deserialization in Java?",
    options: [
      "Serialization is used for primitive types, deserialization is used for objects",
      "There is no difference between them",
      "Serialization converts an object to a byte stream, deserialization converts a byte stream to an object",
      "Serialization converts a byte stream to an object, deserialization converts an object to a byte stream"
    ],
    correctOption: "Serialization converts an object to a byte stream, deserialization converts a byte stream to an object",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to serialize an object in Java?",
    options: [
      "writeObject(obj, file);",
      "new ObjectOutputStream(file).writeObject(obj);",
      "obj.serialize();",
      "Serialize.writeObject(obj);"
    ],
    correctOption: "new ObjectOutputStream(file).writeObject(obj);",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'Externalizable' interface in Java?",
    options: [
      "To prevent a class from being serialized",
      "To define a constant variable",
      "To allow a class to customize its serialization process",
      "To provide a default serialization mechanism"
    ],
    correctOption: "To allow a class to customize its serialization process",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following Java code? \n\nimport java.io.*;\n\nclass MyClass implements Serializable {\n  int x = 10;\n  transient int y = 20;\n}\n\npublic class Main {\n  public static void main(String[] args) throws IOException, ClassNotFoundException {\n    MyClass obj1 = new MyClass();\n    FileOutputStream file = new FileOutputStream(\"temp.txt\");\n    ObjectOutputStream out = new ObjectOutputStream(file);\n    out.writeObject(obj1);\n    out.close();\n    file.close();\n\n    FileInputStream fileIn = new FileInputStream(\"temp.txt\");\n    ObjectInputStream in = new ObjectInputStream(fileIn);\n    MyClass obj2 = (MyClass) in.readObject();\n    in.close();\n    fileIn.close();\n\n    System.out.println(obj2.x + \" \" + obj2.y);\n  }\n}",
    options: [
      "10 20",
      "0 20",
      "0 0",
      "10 0"
    ],
    correctOption: "10 0",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to represent an operation to be performed on the elements of an object structure?",
    options: [
      "Memento",
      "Iterator",
      "Visitor",
      "Interpreter"
    ],
    correctOption: "Visitor",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'assert' keyword in Java?",
    options: [
      "To test assumptions about the program",
      "To define a constant variable",
      "To throw an exception",
      "To prevent a method from being overridden"
    ],
    correctOption: "To test assumptions about the program",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between the 'notify()' and 'notifyAll()' methods in Java?",
    options: [
      "There is no difference between them",
      "'notifyAll()' wakes up all waiting threads, 'notify()' wakes up a single waiting thread",
      "'notify()' wakes up all waiting threads, 'notifyAll()' wakes up a single waiting thread",
      "'notify()' is used for synchronized methods, 'notifyAll()' is used for synchronized blocks"
    ],
    correctOption: "'notifyAll()' wakes up all waiting threads, 'notify()' wakes up a single waiting thread",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is a valid way to use the 'wait()' and 'notify()' methods in Java?",
    options: [
      "wait(obj); notify(obj);",
      "synchronized (obj) { obj.wait(); obj.notify(); }",
      "synchronized (obj) { wait(); notify(); }",
      "obj.wait(); obj.notify();"
    ],
    correctOption: "synchronized (obj) { obj.wait(); obj.notify(); }",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following Java code? \n\npublic class Main {\n  public static void main(String[] args) throws InterruptedException {\n    Object obj = new Object();\n    synchronized (obj) {\n      System.out.println(\"Before wait\");\n      obj.wait();\n      System.out.println(\"After wait\");\n    }\n  }\n}",
    options: [
      "After wait",
      "Before wait\\nAfter wait",
      "Error",
      "Before wait"
    ],
    correctOption: "Before wait",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically?",
    options: [
      "Observer",
      "Interpreter",
      "Iterator",
      "Visitor"
    ],
    correctOption: "Observer",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'clone()' method in Java?",
    options: [
      "To define a new variable",
      "To create a new object",
      "To create a copy of an existing object",
      "To call a static method"
    ],
    correctOption: "To create a copy of an existing object",
    difficulty: "intermediate"
  },
  {
    question: "Which interface must be implemented for a class to use the 'clone()' method in Java?",
    options: [
      "Comparable",
      "Cloneable",
      "Serializable",
      "Runnable"
    ],
    correctOption: "Cloneable",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between a shallow copy and a deep copy when using the 'clone()' method in Java?",
    options: [
      "There is no difference between them",
      "Shallow copy creates a new object and copies references, deep copy creates a new object and copies values",
      "Shallow copy copies only primitive types, deep copy copies all types",
      "Shallow copy creates a new object and copies values, deep copy creates a new object and copies references"
    ],
    correctOption: "Shallow copy creates a new object and copies references, deep copy creates a new object and copies values",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\nclass MyClass implements Cloneable {\n  int x = 10;\n  int[] arr = {1, 2, 3};\n\n  public Object clone() throws CloneNotSupportedException {\n    return super.clone();\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws CloneNotSupportedException {\n    MyClass obj1 = new MyClass();\n    MyClass obj2 = (MyClass) obj1.clone();\n    obj2.x = 20;\n    obj2.arr[0] = 4;\n    System.out.println(obj1.x + \" \" + obj1.arr[0]);\n  }\n}",
    options: [
      "20 1",
      "20 4",
      "10 4",
      "10 1"
    ],
    correctOption: "10 4",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation?",
    options: [
      "Interpreter",
      "Memento",
      "Iterator",
      "Visitor"
    ],
    correctOption: "Iterator",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'Iterable' interface in Java?",
    options: [
      "To allow an object to be iterated over using a loop",
      "To define a new variable",
      "To define a collection of objects",
      "To call a static method"
    ],
    correctOption: "To allow an object to be iterated over using a loop",
    difficulty: "advanced"
  },
  {
    question: "Which interface defines the 'iterator()' method in Java?",
    options: [
      "Collection",
      "Iterator",
      "List",
      "Iterable"
    ],
    correctOption: "Iterable",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following Java code? \n\nimport java.util.*;\n\npublic class Main {\n  public static void main(String[] args) {\n    List<String> list = Arrays.asList(\"A\", \"B\", \"C\");\n    Iterator<String> iterator = list.iterator();\n    while (iterator.hasNext()) {\n      System.out.println(iterator.next());\n    }\n  }\n}",
    options: [
      "[A, B, C]",
      "Error",
      "A B C",
      "A\\nB\\nC"
    ],
    correctOption: "A\nB\nC",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to define a language, provide an interpreter for it, and use this interpreter to interpret sentences in that language?",
    options: [
      "Visitor",
      "Memento",
      "Interpreter",
      "Iterator"
    ],
    correctOption: "Interpreter",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'Memento' pattern?",
    options: [
      "To define a one-to-many dependency between objects",
      "To represent an operation to be performed on the elements of an object structure",
      "To capture and externalize an object's internal state without violating encapsulation",
      "To provide a way to access the elements of an aggregate object sequentially"
    ],
    correctOption: "To capture and externalize an object's internal state without violating encapsulation",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to provide a surrogate or placeholder for another object to control access to it?",
    options: [
      "Facade",
      "Adapter",
      "Proxy",
      "Decorator"
    ],
    correctOption: "Proxy",
    difficulty: "advanced"
  },
  {
    question: "What is the difference between a proxy and a decorator?",
    options: [
      "A decorator provides a different interface, a proxy adds responsibilities",
      "A decorator controls access, a proxy adds responsibilities",
      "A proxy provides a different interface, a decorator adds responsibilities",
      "A proxy controls access, a decorator adds responsibilities"
    ],
    correctOption: "A proxy controls access, a decorator adds responsibilities",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to convert the interface of a class into another interface clients expect?",
    options: [
      "Facade",
      "Decorator",
      "Adapter",
      "Proxy"
    ],
    correctOption: "Adapter",
    difficulty: "beginner"
  },
  {
    question: "What is the primary goal of the Adapter pattern?",
    options: [
      "To define a one-to-many dependency between objects",
      "To dynamically add responsibilities to an object",
      "To create objects without exposing the instantiation logic",
      "To allow classes with incompatible interfaces to work together"
    ],
    correctOption: "To allow classes with incompatible interfaces to work together",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to separate an object's abstraction from its implementation so that both can evolve independently?",
    options: [
      "Bridge",
      "Decorator",
      "Adapter",
      "Facade"
    ],
    correctOption: "Bridge",
    difficulty: "beginner"
  },
  {
    question: "What is the key difference between the Bridge and Adapter patterns?",
    options: [
      "Adapter changes the interface of a class, Bridge changes the implementation",
      "Bridge changes the interface of a class, Adapter changes the implementation",
      "Adapter is about different abstractions, Bridge is about different interfaces",
      "Bridge is about different abstractions, Adapter is about different interfaces"
    ],
    correctOption: "Bridge is about different abstractions, Adapter is about different interfaces",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to define an object that simplifies the interface to a complex subsystem?",
    options: [
      "Decorator",
      "Facade",
      "Proxy",
      "Adapter"
    ],
    correctOption: "Facade",
    difficulty: "advanced"
  },
  {
    question: "What is the main advantage of using the Facade pattern?",
    options: [
      "It provides a surrogate or placeholder for another object",
      "It allows classes with incompatible interfaces to work together",
      "It dynamically adds responsibilities to an object",
      "It reduces the complexity of using a subsystem"
    ],
    correctOption: "It reduces the complexity of using a subsystem",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is NOT a creational design pattern?",
    options: [
      "Factory",
      "Observer",
      "Builder",
      "Singleton"
    ],
    correctOption: "Observer",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is NOT a structural design pattern?",
    options: [
      "Template Method",
      "Facade",
      "Adapter",
      "Bridge"
    ],
    correctOption: "Template Method",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is NOT a behavioral design pattern?",
    options: [
      "Iterator",
      "Visitor",
      "Factory",
      "Interpreter"
    ],
    correctOption: "Factory",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the Singleton pattern?",
    options: [
      "To provide a way to access the elements of an aggregate object sequentially",
      "To create multiple instances of a class",
      "To define a one-to-many dependency between objects",
      "To ensure that a class has only one instance and provide a global point of access to it"
    ],
    correctOption: "To ensure that a class has only one instance and provide a global point of access to it",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to implement the Singleton pattern in Java?",
    options: [
      "public class Singleton { private static Singleton instance = new Singleton(); public Singleton() {} public static Singleton getInstance() { return instance; } }",
      "public class Singleton { public Singleton() {} public static Singleton getInstance() { return new Singleton(); } }",
      "public class Singleton { private static Singleton instance; public Singleton() {} public static Singleton getInstance() { return new Singleton(); } }",
      "public class Singleton { private static Singleton instance; public Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }"
    ],
    correctOption: "public class Singleton { private static Singleton instance; public Singleton() {} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the Factory pattern?",
    options: [
      "To capture and externalize an object's internal state without violating encapsulation",
      "To create objects without exposing the instantiation logic to the client",
      "To provide a way to access the elements of an aggregate object sequentially",
      "To define a one-to-many dependency between objects"
    ],
    correctOption: "To create objects without exposing the instantiation logic to the client",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to construct complex objects step by step?",
    options: [
      "Builder",
      "Singleton",
      "Prototype",
      "Factory"
    ],
    correctOption: "Builder",
    difficulty: "intermediate"
  },
  {
    question: "What is the difference between the Factory and Builder patterns?",
    options: [
      "Factory is used for simple objects, Builder is used for complex objects",
      "Builder is used for simple objects, Factory is used for complex objects",
      "Factory creates objects in a single step, Builder creates objects step by step",
      "Builder creates objects in a single step, Factory creates objects step by step"
    ],
    correctOption: "Factory creates objects in a single step, Builder creates objects step by step",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to create new objects by cloning an existing object?",
    options: [
      "Builder",
      "Prototype",
      "Factory",
      "Singleton"
    ],
    correctOption: "Prototype",
    difficulty: "intermediate"
  },
  {
    question: "What is the main advantage of using the Prototype pattern?",
    options: [
      "It simplifies the creation of complex objects",
      "It improves performance by cloning objects instead of creating them from scratch",
      "It ensures that a class has only one instance",
      "It reduces the number of classes needed"
    ],
    correctOption: "It improves performance by cloning objects instead of creating them from scratch",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is NOT a valid way to implement the Prototype pattern in Java?",
    options: [
      "Using serialization and deserialization",
      "Implementing the Cloneable interface",
      "Using a copy constructor",
      "Using the 'new' keyword"
    ],
    correctOption: "Using the 'new' keyword",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\nclass MyClass implements Cloneable {\n  int x = 10;\n  public Object clone() throws CloneNotSupportedException {\n    return super.clone();\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws CloneNotSupportedException {\n    MyClass obj1 = new MyClass();\n    MyClass obj2 = (MyClass) obj1.clone();\n    System.out.println(obj1.x == obj2.x);\n  }\n}",
    options: [
      "Null",
      "true",
      "Error",
      "false"
    ],
    correctOption: "true",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to define the skeleton of an algorithm in the superclass but lets subclasses redefine certain steps of the algorithm without changing the algorithm's structure?",
    options: [
      "Template Method",
      "Strategy",
      "Factory",
      "Observer"
    ],
    correctOption: "Template Method",
    difficulty: "intermediate"
  },
  {
    question: "What is the main advantage of using the Template Method pattern?",
    options: [
      "It allows classes with incompatible interfaces to work together",
      "It dynamically adds responsibilities to an object",
      "It provides a surrogate or placeholder for another object",
      "It reduces code duplication and promotes code reuse"
    ],
    correctOption: "It reduces code duplication and promotes code reuse",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to define a family of algorithms, encapsulate each one, and make them interchangeable?",
    options: [
      "Singleton",
      "Strategy",
      "Observer",
      "Factory"
    ],
    correctOption: "Strategy",
    difficulty: "intermediate"
  },
  {
    question: "What is the key difference between the Strategy and Template Method patterns?",
    options: [
      "Template Method defines the skeleton of an algorithm, Strategy defines a family of algorithms",
      "Strategy defines the skeleton of an algorithm, Template Method defines a family of algorithms",
      "Strategy is about inheritance, Template Method is about composition",
      "Template Method is about inheritance, Strategy is about composition"
    ],
    correctOption: "Template Method defines the skeleton of an algorithm, Strategy defines a family of algorithms",
    difficulty: "intermediate"
  },
  {
    question: "What is the main advantage of using the Observer pattern?",
    options: [
      "It provides a way to access the elements of an aggregate object sequentially",
      "It represents an operation to be performed on the elements of an object structure",
      "It allows loose coupling between objects",
      "It captures and externalizes an object's internal state without violating encapsulation"
    ],
    correctOption: "It allows loose coupling between objects",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is a valid way to implement the Observer pattern in Java?",
    options: [
      "Using the 'observer' keyword",
      "Using the 'notify()' and 'notifyAll()' methods",
      "Implementing the Observer interface and using the Observable class",
      "Using the 'listener' keyword"
    ],
    correctOption: "Implementing the Observer interface and using the Observable class",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'Observable' class in Java?",
    options: [
      "To define a new variable",
      "To call a static method",
      "To represent an object that can be observed",
      "To define an observer"
    ],
    correctOption: "To represent an object that can be observed",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'Observer' interface in Java?",
    options: [
      "To call a static method",
      "To define a new variable",
      "To represent an object that can be observed",
      "To define an observer"
    ],
    correctOption: "To define an observer",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following Java code? \n\nimport java.util.*;\n\nclass MyObserver implements Observer {\n  public void update(Observable obj, Object arg) {\n    System.out.println(\"Update received: \" + arg);\n  }\n}\n\nclass MyObservable extends Observable {\n  public void doSomething() {\n    setChanged();\n    notifyObservers(\"Data changed\");\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    MyObservable observable = new MyObservable();\n    MyObserver observer = new MyObserver();\n    observable.addObserver(observer);\n    observable.doSomething();\n  }\n}",
    options: [
      "Update received: Data changed",
      "Data changed",
      "Error",
      "Observer notified"
    ],
    correctOption: "Update received: Data changed",
    difficulty: "beginner"
  },
  {
    question: "What is the primary purpose of the Proxy pattern?",
    options: [
      "To create objects without exposing the instantiation logic",
      "To control access to another object",
      "To dynamically add responsibilities to an object",
      "To define a one-to-many dependency between objects"
    ],
    correctOption: "To control access to another object",
    difficulty: "advanced"
  },
  {
    question: "What is the key difference between the Decorator and Adapter patterns?",
    options: [
      "Adapter changes the interface, Decorator changes the implementation",
      "Adapter adds responsibilities, Decorator allows incompatible interfaces to work together",
      "Decorator adds responsibilities, Adapter allows incompatible interfaces to work together",
      "Decorator changes the interface, Adapter changes the implementation"
    ],
    correctOption: "Decorator adds responsibilities, Adapter allows incompatible interfaces to work together",
    difficulty: "beginner"
  },
  {
    question: "What is the main advantage of using the Visitor pattern?",
    options: [
      "It allows you to add new operations to object structures without changing the classes of the elements",
      "It provides a way to access the elements of an aggregate object sequentially",
      "It defines a language, provide an interpreter for it, and use this interpreter to interpret sentences in that language",
      "It captures and externalizes an object's internal state without violating encapsulation"
    ],
    correctOption: "It allows you to add new operations to object structures without changing the classes of the elements",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to capture and externalize an object's internal state without violating encapsulation?",
    options: [
      "Iterator",
      "Visitor",
      "Memento",
      "State"
    ],
    correctOption: "Memento",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the Memento pattern?",
    options: [
      "To define a one-to-many dependency between objects",
      "To allow an object to be restored to its previous state",
      "To represent an operation to be performed on the elements of an object structure",
      "To provide a way to access the elements of an aggregate object sequentially"
    ],
    correctOption: "To allow an object to be restored to its previous state",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to allow an object to alter its behavior when its internal state changes?",
    options: [
      "Memento",
      "Observer",
      "State",
      "Strategy"
    ],
    correctOption: "State",
    difficulty: "beginner"
  },
  {
    question: "What is the key difference between the State and Strategy patterns?",
    options: [
      "State defines a family of algorithms, State allows an object to alter its behavior",
      "Strategy is about inheritance, State is about composition",
      "Strategy defines a family of algorithms, State allows an object to alter its behavior",
      "State is about inheritance, Strategy is about composition"
    ],
    correctOption: "Strategy defines a family of algorithms, State allows an object to alter its behavior",
    difficulty: "advanced"
  },
  {
    question: "What is the primary goal of the Interpreter pattern?",
    options: [
      "To define a one-to-many dependency between objects",
      "To provide a way to access the elements of an aggregate object sequentially",
      "To represent a grammar for a language and provide a way to evaluate expressions in that language",
      "To represent an operation to be performed on the elements of an object structure"
    ],
    correctOption: "To represent a grammar for a language and provide a way to evaluate expressions in that language",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to decouple an abstraction from its implementation so that the two can vary independently?",
    options: [
      "Adapter",
      "Facade",
      "Bridge",
      "Decorator"
    ],
    correctOption: "Bridge",
    difficulty: "beginner"
  },
  {
    question: "What is the primary purpose of the Bridge pattern?",
    options: [
      "To dynamically add responsibilities to an object",
      "To create objects without exposing the instantiation logic",
      "To define a one-to-many dependency between objects",
      "To allow an abstraction and its implementation to evolve independently"
    ],
    correctOption: "To allow an abstraction and its implementation to evolve independently",
    difficulty: "intermediate"
  },
  {
    question: "What is the main advantage of using the Adapter pattern?",
    options: [
      "It dynamically adds responsibilities to an object",
      "It reduces the complexity of using a subsystem",
      "It provides a surrogate or placeholder for another object",
      "It allows classes with incompatible interfaces to work together"
    ],
    correctOption: "It allows classes with incompatible interfaces to work together",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to ensure a class only has one instance, and provide a global point of access to it?",
    options: [
      "Prototype",
      "Factory",
      "Builder",
      "Singleton"
    ],
    correctOption: "Singleton",
    difficulty: "intermediate"
  },
  {
    question: "What is the primary goal of the Singleton pattern?",
    options: [
      "To create multiple instances of a class",
      "To control the instantiation of a class and provide a single access point",
      "To provide a way to access the elements of an aggregate object sequentially",
      "To define a one-to-many dependency between objects"
    ],
    correctOption: "To control the instantiation of a class and provide a single access point",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to create families of related or dependent objects without specifying their concrete classes?",
    options: [
      "Prototype",
      "Abstract Factory",
      "Builder",
      "Factory Method"
    ],
    correctOption: "Abstract Factory",
    difficulty: "beginner"
  },
  {
    question: "What is the key difference between Factory Method and Abstract Factory?",
    options: [
      "Abstract Factory is an interface, Factory Method is a class",
      "Factory Method creates a single object, Abstract Factory creates families of objects",
      "Factory Method is an interface, Abstract Factory is a class",
      "Abstract Factory creates a single object, Factory Method creates families of objects"
    ],
    correctOption: "Factory Method creates a single object, Abstract Factory creates families of objects",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to construct complex objects step by step, allowing the construction process to create different representations of the object?",
    options: [
      "Factory",
      "Builder",
      "Prototype",
      "Abstract Factory"
    ],
    correctOption: "Builder",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of the Builder pattern?",
    options: [
      "It ensures a class has only one instance",
      "It simplifies the creation of simple objects",
      "It creates objects without exposing the instantiation logic",
      "It allows the creation of complex objects with different configurations"
    ],
    correctOption: "It allows the creation of complex objects with different configurations",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype?",
    options: [
      "Prototype",
      "Builder",
      "Factory",
      "Singleton"
    ],
    correctOption: "Prototype",
    difficulty: "intermediate"
  },
  {
    question: "What is the main benefit of using the Prototype pattern?",
    options: [
      "Improved performance by cloning instead of creating from scratch",
      "Reduced number of classes",
      "Simplified creation of complex object hierarchies",
      "Guaranteed single instance of a class"
    ],
    correctOption: "Improved performance by cloning instead of creating from scratch",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to define a high-level interface that simplifies a complex subsystem?",
    options: [
      "Proxy",
      "Facade",
      "Adapter",
      "Decorator"
    ],
    correctOption: "Facade",
    difficulty: "advanced"
  },
  {
    question: "What is the primary purpose of the Facade pattern?",
    options: [
      "To allow classes with incompatible interfaces to work together",
      "To provide a simplified interface to a complex system",
      "To control access to another object",
      "To add responsibilities to objects dynamically"
    ],
    correctOption: "To provide a simplified interface to a complex system",
    difficulty: "beginner"
  },
  {
    question: "What is the key difference between Proxy and Decorator?",
    options: [
      "Decorator controls access, Proxy adds responsibilities",
      "Proxy changes the interface, Decorator adds behavior",
      "Decorator changes the interface, Proxy adds behavior",
      "Proxy controls access, Decorator adds responsibilities"
    ],
    correctOption: "Proxy controls access, Decorator adds responsibilities",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to attach additional responsibilities to an object dynamically?",
    options: [
      "Adapter",
      "Bridge",
      "Facade",
      "Decorator"
    ],
    correctOption: "Decorator",
    difficulty: "advanced"
  },
  {
    question: "What is the main advantage of using the Decorator pattern?",
    options: [
      "It simplifies the interface to a complex subsystem",
      "It adds behavior to an object without altering its class",
      "It allows classes with incompatible interfaces to work together",
      "It provides a surrogate for another object"
    ],
    correctOption: "It adds behavior to an object without altering its class",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to compose objects into tree structures to represent part-whole hierarchies?",
    options: [
      "Facade",
      "Bridge",
      "Composite",
      "Decorator"
    ],
    correctOption: "Composite",
    difficulty: "intermediate"
  },
  {
    question: "What is the primary purpose of the Composite pattern?",
    options: [
      "To convert the interface of a class into another interface clients expect",
      "To provide a simplified interface to a complex subsystem",
      "To define a one-to-many dependency between objects",
      "To allow clients to treat individual objects and compositions of objects uniformly"
    ],
    correctOption: "To allow clients to treat individual objects and compositions of objects uniformly",
    difficulty: "intermediate"
  },
  {
    question: "Which design pattern is used to separate an object's abstraction from its implementation so that the two can vary independently?",
    options: [
      "Facade",
      "Adapter",
      "Bridge",
      "Decorator"
    ],
    correctOption: "Bridge",
    difficulty: "beginner"
  },
  {
    question: "What is the main advantage of using the Bridge pattern?",
    options: [
      "It simplifies the interface to a complex subsystem",
      "It allows classes with incompatible interfaces to work together",
      "It decouples an abstraction from its implementation",
      "It dynamically adds responsibilities to an object"
    ],
    correctOption: "It decouples an abstraction from its implementation",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to define the skeleton of an algorithm in the superclass but defers some steps to subclasses without changing the algorithm's structure?",
    options: [
      "Template Method",
      "Strategy",
      "Observer",
      "Visitor"
    ],
    correctOption: "Template Method",
    difficulty: "advanced"
  },
  {
    question: "What is the primary benefit of using the Template Method pattern?",
    options: [
      "It allows objects to change their behavior at runtime",
      "It defines a one-to-many dependency between objects",
      "It provides a way to access the elements of an aggregate object sequentially",
      "It promotes code reuse by defining common steps in a superclass"
    ],
    correctOption: "It promotes code reuse by defining common steps in a superclass",
    difficulty: "advanced"
  },
  {
    question: "What is the key advantage of using the Strategy pattern?",
    options: [
      "It provides a way to access the elements of an aggregate object sequentially",
      "It allows objects to change their behavior at runtime",
      "It promotes code reuse by defining common steps in a superclass",
      "It defines a one-to-many dependency between objects"
    ],
    correctOption: "It allows objects to change their behavior at runtime",
    difficulty: "advanced"
  },
  {
    question: "What is the primary purpose of the Observer pattern?",
    options: [
      "To provide a way to access the elements of an aggregate object sequentially",
      "To notify dependent objects of state changes",
      "To allow objects to change their behavior at runtime",
      "To promote code reuse by defining common steps in a superclass"
    ],
    correctOption: "To notify dependent objects of state changes",
    difficulty: "advanced"
  },
  {
    question: "What is the main advantage of using the Iterator pattern?",
    options: [
      "It allows objects to change their behavior at runtime",
      "It provides a consistent way to traverse different data structures",
      "It defines a one-to-many dependency between objects",
      "It promotes code reuse by defining common steps in a superclass"
    ],
    correctOption: "It provides a consistent way to traverse different data structures",
    difficulty: "advanced"
  },
  {
    question: "Which design pattern is used to represent an operation to be performed on the elements of an object structure, allowing you to define a new operation without changing the classes of the elements on which it operates?",
    options: [
      "State",
      "Iterator",
      "Memento",
      "Visitor"
    ],
    correctOption: "Visitor",
    difficulty: "beginner"
  },
  {
    question: "What is the primary benefit of using the Visitor pattern?",
    options: [
      "It promotes code reuse by defining common steps in a superclass",
      "It allows objects to change their behavior at runtime",
      "It allows adding new operations to a structure without modifying the structure's classes",
      "It provides a way to access the elements of an aggregate object sequentially"
    ],
    correctOption: "It allows adding new operations to a structure without modifying the structure's classes",
    difficulty: "advanced"
  },
  {
    question: "What is the main purpose of the Memento pattern?",
    options: [
      "To allow objects to change their behavior at runtime",
      "To enable restoring an object to a previous state",
      "To promote code reuse by defining common steps in a superclass",
      "To provide a way to access the elements of an aggregate object sequentially"
    ],
    correctOption: "To enable restoring an object to a previous state",
    difficulty: "beginner"
  },
  {
    question: "Which design pattern is used to define an object that encapsulates how a set of objects interact?",
    options: [
      "Strategy",
      "Mediator",
      "Observer",
      "Template Method"
    ],
    correctOption: "Mediator",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of using the Mediator pattern?",
    options: [
      "It reduces coupling between objects by centralizing their interaction",
      "It promotes code reuse by defining common steps in a superclass",
      "It provides a way to access the elements of an aggregate object sequentially",
      "It allows objects to change their behavior at runtime"
    ],
    correctOption: "It reduces coupling between objects by centralizing their interaction",
    difficulty: "advanced"
  },
  {
    question: "What is the main purpose of the Interpreter pattern?",
    options: [
      "To represent a grammar and interpret sentences in that grammar",
      "To provide a way to access the elements of an aggregate object sequentially",
      "To allow objects to change their behavior at runtime",
      "To promote code reuse by defining common steps in a superclass"
    ],
    correctOption: "To represent a grammar and interpret sentences in that grammar",
    difficulty: "advanced"
  },
  {
    question: "What is the primary benefit of using the Prototype pattern?",
    options: [
      "It simplifies the creation of complex object hierarchies",
      "It provides a way to access the elements of an aggregate object sequentially",
      "It improves performance by cloning objects instead of creating them from scratch",
      "It allows objects to change their behavior at runtime"
    ],
    correctOption: "It improves performance by cloning objects instead of creating them from scratch",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of using the Facade pattern?",
    options: [
      "It reduces the complexity of using a subsystem",
      "It dynamically adds responsibilities to an object",
      "It provides a surrogate or placeholder for another object",
      "It allows classes with incompatible interfaces to work together"
    ],
    correctOption: "It reduces the complexity of using a subsystem",
    difficulty: "beginner"
  },
  {
    question: "What is the primary purpose of the Interpreter pattern?",
    options: [
      "To provide a way to access the elements of an aggregate object sequentially",
      "To define a one-to-many dependency between objects",
      "To represent a grammar and interpret sentences in that grammar",
      "To allow objects to change their behavior at runtime"
    ],
    correctOption: "To represent a grammar and interpret sentences in that grammar",
    difficulty: "advanced"
  },
  {
    question: "What is the primary purpose of the Memento pattern?",
    options: [
      "To provide a way to access the elements of an aggregate object sequentially",
      "To define a one-to-many dependency between objects",
      "To enable restoring an object to a previous state",
      "To allow objects to change their behavior at runtime"
    ],
    correctOption: "To enable restoring an object to a previous state",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of using the State pattern?",
    options: [
      "It allows objects to change their behavior at runtime",
      "It enables restoring an object to a previous state",
      "It provides a way to access the elements of an aggregate object sequentially",
      "It defines a one-to-many dependency between objects"
    ],
    correctOption: "It allows objects to change their behavior at runtime",
    difficulty: "advanced"
  },
  {
    question: "What is the primary advantage of using the Strategy pattern?",
    options: [
      "It provides a way to access the elements of an aggregate object sequentially",
      "It defines a one-to-many dependency between objects",
      "It promotes code reuse by defining common steps in a superclass",
      "It allows objects to change their behavior at runtime"
    ],
    correctOption: "It allows objects to change their behavior at runtime",
    difficulty: "advanced"
  },
  {
    question: "What is Object Oriented Programming in C++?",
    options: [
      "A way to write HTML",
      "A method to compile Java",
      "A type of database",
      "A programming paradigm based on objects"
    ],
    correctOption: "A programming paradigm based on objects",
    difficulty: "beginner"
  },
  {
    question: "Which keyword is used to create a class in C++?",
    options: [
      "define",
      "object",
      "struct",
      "class"
    ],
    correctOption: "class",
    difficulty: "beginner"
  },
  {
    question: "What is an object in C++?",
    options: [
      "A library",
      "An instance of a class",
      "A function",
      "A loop"
    ],
    correctOption: "An instance of a class",
    difficulty: "beginner"
  },
  {
    question: "Which of these is a principle of OOP?",
    options: [
      "Both Encapsulation and Polymorphism",
      "Polymorphism",
      "Encapsulation",
      "Recursion"
    ],
    correctOption: "Both Encapsulation and Polymorphism",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of a constructor in C++?",
    options: [
      "To destroy objects",
      "To initialize objects",
      "To call main",
      "To compile code"
    ],
    correctOption: "To initialize objects",
    difficulty: "beginner"
  },
  {
    question: "Which access specifier makes a member accessible only within its class?",
    options: [
      "public",
      "private",
      "external",
      "protected"
    ],
    correctOption: "private",
    difficulty: "beginner"
  },
  {
    question: "What symbol is used to access members of a class using an object?",
    options: [
      ".",
      "::",
      "#",
      "->"
    ],
    correctOption: ".",
    difficulty: "beginner"
  },
  {
    question: "Which of these is used to destroy objects?",
    options: [
      "Operator",
      "Constructor",
      "Function",
      "Destructor"
    ],
    correctOption: "Destructor",
    difficulty: "beginner"
  },
  {
    question: "What is the default access specifier for class members?",
    options: [
      "protected",
      "private",
      "public",
      "static"
    ],
    correctOption: "private",
    difficulty: "beginner"
  },
  {
    question: "Which of these is NOT a feature of OOP?",
    options: [
      "Compilation",
      "Inheritance",
      "Encapsulation",
      "Abstraction"
    ],
    correctOption: "Compilation",
    difficulty: "beginner"
  },
  {
    question: "What is function overloading in C++?",
    options: [
      "Using functions from other languages",
      "Functions with same body",
      "Global functions only",
      "Multiple functions with same name but different parameters"
    ],
    correctOption: "Multiple functions with same name but different parameters",
    difficulty: "intermediate"
  },
  {
    question: "Which feature allows a class to inherit from another?",
    options: [
      "Overloading",
      "Polymorphism",
      "Inheritance",
      "Encapsulation"
    ],
    correctOption: "Inheritance",
    difficulty: "intermediate"
  },
  {
    question: "What is 'this' pointer in C++?",
    options: [
      "Pointer to class type",
      "Pointer to base class",
      "Pointer to current object",
      "Global pointer"
    ],
    correctOption: "Pointer to current object",
    difficulty: "intermediate"
  },
  {
    question: "What is a virtual function?",
    options: [
      "A static function",
      "A non-returning function",
      "A function that can be overridden in derived class",
      "A function defined in a namespace"
    ],
    correctOption: "A function that can be overridden in derived class",
    difficulty: "intermediate"
  },
  {
    question: "Which type of inheritance is not supported in C++?",
    options: [
      "Multiple",
      "Multilevel",
      "All types supported",
      "Single"
    ],
    correctOption: "All types supported",
    difficulty: "intermediate"
  },
  {
    question: "What does the scope resolution operator (::) do?",
    options: [
      "Defines a new class",
      "Destroys an object",
      "Access private data",
      "Access global variables or class methods"
    ],
    correctOption: "Access global variables or class methods",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following best describes polymorphism?",
    options: [
      "Code optimization",
      "Code repetition",
      "Ability to take many forms",
      "Static typing"
    ],
    correctOption: "Ability to take many forms",
    difficulty: "intermediate"
  },
  {
    question: "Which concept ensures only one copy of a member is shared by all objects?",
    options: [
      "Virtual member",
      "Static member",
      "Private member",
      "Const member"
    ],
    correctOption: "Static member",
    difficulty: "intermediate"
  },
  {
    question: "Which is used to prevent inheritance?",
    options: [
      "final keyword",
      "stop keyword",
      "break statement",
      "sealed class"
    ],
    correctOption: "final keyword",
    difficulty: "intermediate"
  },
  {
    question: "What is operator overloading?",
    options: [
      "Modifying header files",
      "Compiling multiple operators",
      "Redefining operator for user-defined types",
      "Reusing global operators"
    ],
    correctOption: "Redefining operator for user-defined types",
    difficulty: "intermediate"
  },
  {
    question: "Which is the correct syntax for a constructor?",
    options: [
      "void ClassName() {}",
      "ClassName() {}",
      "int ClassName {}",
      "ClassName.create()"
    ],
    correctOption: "ClassName() {}",
    difficulty: "intermediate"
  },
  {
    question: "Which keyword is used to inherit publicly from a class?",
    options: [
      "public",
      "base",
      "inherits",
      "extends"
    ],
    correctOption: "public",
    difficulty: "intermediate"
  },
  {
    question: "Which access specifier allows members to be accessed in derived classes but not outside?",
    options: [
      "private",
      "protected",
      "public",
      "internal"
    ],
    correctOption: "protected",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is false about constructors?",
    options: [
      "Can be default",
      "Can be inherited",
      "Can be parameterized",
      "Can be overloaded"
    ],
    correctOption: "Can be inherited",
    difficulty: "intermediate"
  },
  {
    question: "In C++, which of the following is true about virtual destructors?",
    options: [
      "They are automatically generated by the compiler if not defined.",
      "They are only necessary when a class has at least one pure virtual function.",
      "They prevent memory leaks when deleting objects through a base-class pointer.",
      "They cannot be declared as pure virtual."
    ],
    correctOption: "They prevent memory leaks when deleting objects through a base-class pointer.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet if a Diamond Problem occurs in multiple inheritance?",
    options: [
      "The base class's method is called.",
      "The most derived class's method is called.",
      "Compilation error due to ambiguity.",
      "Runtime error."
    ],
    correctOption: "Compilation error due to ambiguity.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following best describes the 'Rule of Three' in C++?",
    options: [
      "If a class defines a destructor, copy constructor, or copy assignment operator, it should define all three.",
      "A class should have no more than three member variables.",
      "A class should not have more than three virtual functions.",
      "A class should have at least three constructors."
    ],
    correctOption: "If a class defines a destructor, copy constructor, or copy assignment operator, it should define all three.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'explicit' keyword in C++?",
    options: [
      "To enable dynamic polymorphism.",
      "To allow a function to be overridden in derived classes.",
      "To enforce runtime type checking.",
      "To prevent implicit conversions for constructors with a single parameter."
    ],
    correctOption: "To prevent implicit conversions for constructors with a single parameter.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about move semantics in C++?",
    options: [
      "They allow efficient transfer of resources from temporary objects.",
      "They replace the need for copy constructors.",
      "They are only applicable to primitive data types.",
      "They cannot be used with STL containers."
    ],
    correctOption: "They allow efficient transfer of resources from temporary objects.",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following code snippet involving a lambda function with capture-by-reference?",
    options: [
      "A compile-time error due to invalid capture.",
      "A runtime error due to dangling reference.",
      "The value of the captured variable at the time of lambda invocation.",
      "The value of the captured variable at the time of lambda definition."
    ],
    correctOption: "The value of the captured variable at the time of lambda invocation.",
    difficulty: "advanced"
  },
  {
    question: "In C++, what is the effect of declaring a member function as 'const'?",
    options: [
      "Both A and B.",
      "It allows the function to be called on const objects.",
      "It makes the function implicitly inline.",
      "It prevents the function from modifying any member variables."
    ],
    correctOption: "Both A and B.",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about the 'mutable' keyword in C++?",
    options: [
      "It allows modification of a member variable in a const member function.",
      "It enforces compile-time initialization of a member variable.",
      "It prevents a member variable from being modified.",
      "It makes a member variable thread-safe."
    ],
    correctOption: "It allows modification of a member variable in a const member function.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'final' keyword when applied to a class in C++?",
    options: [
      "To enforce static initialization of the class.",
      "To prevent dynamic allocation of the class.",
      "To make all member functions of the class const.",
      "To prevent the class from being inherited."
    ],
    correctOption: "To prevent the class from being inherited.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following best describes the 'Curiously Recurring Template Pattern' (CRTP) in C++?",
    options: [
      "A template that can only be instantiated once.",
      "A recursive template that expands infinitely at compile-time.",
      "A pattern to implement runtime polymorphism without virtual functions.",
      "A class template inherits from a template specialization using itself as a template argument."
    ],
    correctOption: "A class template inherits from a template specialization using itself as a template argument.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a deleted function in C++?",
    options: [
      "The default implementation is used instead.",
      "Undefined behavior.",
      "Runtime error.",
      "Compilation error due to attempt to use a deleted function."
    ],
    correctOption: "Compilation error due to attempt to use a deleted function.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'override' keyword in C++?",
    options: [
      "It is optional and has no effect on compilation.",
      "It allows a function to override non-virtual functions.",
      "It prevents a function from being overridden in derived classes.",
      "It explicitly indicates that a function is intended to override a virtual function in a base class."
    ],
    correctOption: "It explicitly indicates that a function is intended to override a virtual function in a base class.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'noexcept' specifier in C++?",
    options: [
      "To enforce exception handling in a function.",
      "To allow a function to throw exceptions.",
      "To disable exception handling in a program.",
      "To indicate that a function does not throw exceptions."
    ],
    correctOption: "To indicate that a function does not throw exceptions.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::array' in C++?",
    options: [
      "It cannot be used with range-based for loops.",
      "It is a fixed-size array that can be used with STL algorithms.",
      "It is a dynamic array that can change size at runtime.",
      "It is a deprecated feature in C++11."
    ],
    correctOption: "It is a fixed-size array that can be used with STL algorithms.",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following code snippet involving a reference variable?",
    options: [
      "The value of the original variable.",
      "The address of the original variable.",
      "Undefined behavior.",
      "A compile-time error due to invalid reference."
    ],
    correctOption: "The value of the original variable.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::initializer_list' in C++?",
    options: [
      "It is a deprecated feature in C++11.",
      "It allows initialization of containers with a list of values.",
      "It is used to create a list of function arguments.",
      "It cannot be used with range-based for loops."
    ],
    correctOption: "It allows initialization of containers with a list of values.",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'friend' keyword in C++?",
    options: [
      "To allow a function or class to access private members of another class.",
      "To define a function template.",
      "To prevent a class from being inherited.",
      "To declare a function as a global function."
    ],
    correctOption: "To allow a function or class to access private members of another class.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::tuple' in C++?",
    options: [
      "It is a deprecated feature in C++11.",
      "It cannot be used with STL algorithms.",
      "It is a dynamic array that can change size at runtime.",
      "It can hold a fixed number of elements of different types."
    ],
    correctOption: "It can hold a fixed number of elements of different types.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a static member variable?",
    options: [
      "The address of the static member variable.",
      "The value of the static member variable.",
      "Undefined behavior.",
      "A compile-time error due to invalid access."
    ],
    correctOption: "The value of the static member variable.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::string' in C++?",
    options: [
      "It cannot be used with STL algorithms.",
      "It is a deprecated feature in C++11.",
      "It is a fixed-size array of characters.",
      "It is a mutable sequence of characters."
    ],
    correctOption: "It is a mutable sequence of characters.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'const_cast' operator in C++?",
    options: [
      "To cast away the constness of a variable.",
      "To cast a variable to a different type.",
      "To enforce const correctness.",
      "To create a constant reference."
    ],
    correctOption: "To cast away the constness of a variable.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::vector' in C++?",
    options: [
      "It is a fixed-size array.",
      "It is a deprecated feature in C++11.",
      "It is a dynamic array that can change size at runtime.",
      "It cannot be used with STL algorithms."
    ],
    correctOption: "It is a dynamic array that can change size at runtime.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a nullptr?",
    options: [
      "Undefined behavior.",
      "A null pointer.",
      "A compile-time error.",
      "A runtime error."
    ],
    correctOption: "A null pointer.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::map' in C++?",
    options: [
      "It is a fixed-size array.",
      "It cannot be used with STL algorithms.",
      "It is an associative container that stores elements in key-value pairs.",
      "It is a deprecated feature in C++11."
    ],
    correctOption: "It is an associative container that stores elements in key-value pairs.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'static_cast' operator in C++?",
    options: [
      "To perform a safe conversion between types.",
      "To enforce const correctness.",
      "To create a constant reference.",
      "To cast away the constness of a variable."
    ],
    correctOption: "To perform a safe conversion between types.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::deque' in C++?",
    options: [
      "It cannot be used with STL algorithms.",
      "It is a deprecated feature in C++11.",
      "It is a fixed-size array.",
      "It is a double-ended queue that allows insertion and deletion at both ends."
    ],
    correctOption: "It is a double-ended queue that allows insertion and deletion at both ends.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::set' in C++?",
    options: [
      "It is a deprecated feature in C++11.",
      "It is a fixed-size array.",
      "It cannot be used with STL algorithms.",
      "It is an associative container that stores unique elements in a specific order."
    ],
    correctOption: "It is an associative container that stores unique elements in a specific order.",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'reinterpret_cast' operator in C++?",
    options: [
      "To cast away the constness of a variable.",
      "To enforce const correctness.",
      "To perform low-level casts between unrelated types.",
      "To create a constant reference."
    ],
    correctOption: "To perform low-level casts between unrelated types.",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about the 'std::unordered_map' in C++?",
    options: [
      "It is a fixed-size array.",
      "It is an associative container that stores elements in key-value pairs without any specific order.",
      "It is a deprecated feature in C++11.",
      "It cannot be used with STL algorithms."
    ],
    correctOption: "It is an associative container that stores elements in key-value pairs without any specific order.",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following code snippet involving a lambda function with capture-by-value?",
    options: [
      "A compile-time error due to invalid capture.",
      "The value of the captured variable at the time of lambda definition.",
      "The value of the captured variable at the time of lambda invocation.",
      "A runtime error due to dangling reference."
    ],
    correctOption: "The value of the captured variable at the time of lambda definition.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::list' in C++?",
    options: [
      "It is a doubly linked list that allows insertion and deletion at any position.",
      "It is a fixed-size array.",
      "It is a deprecated feature in C++11.",
      "It cannot be used with STL algorithms."
    ],
    correctOption: "It is a doubly linked list that allows insertion and deletion at any position.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'std::thread' class in C++?",
    options: [
      "To represent a single thread of execution.",
      "To manage multiple threads in a program.",
      "To synchronize access to shared resources.",
      "To create a thread pool."
    ],
    correctOption: "To represent a single thread of execution.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::mutex' in C++?",
    options: [
      "It is a deprecated feature in C++11.",
      "It cannot be used with lambda functions.",
      "It is used to protect shared data from being simultaneously accessed by multiple threads.",
      "It is a type of STL container."
    ],
    correctOption: "It is used to protect shared data from being simultaneously accessed by multiple threads.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'volatile' keyword in C++?",
    options: [
      "To prevent a variable from being modified.",
      "To make a variable thread-local.",
      "To enforce atomic access to a variable.",
      "To indicate that a variable may change unexpectedly, preventing compiler optimizations."
    ],
    correctOption: "To indicate that a variable may change unexpectedly, preventing compiler optimizations.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::enable_if' template in C++?",
    options: [
      "It ensures exception safety in template functions.",
      "It is used to disable copy constructors.",
      "It is used for conditional compilation based on type traits.",
      "It enables a function only if a certain condition is met at runtime."
    ],
    correctOption: "It is used for conditional compilation based on type traits.",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following code snippet involving a variadic template?",
    options: [
      "The sum of all provided arguments.",
      "The first argument only.",
      "Undefined behavior.",
      "A compile-time error due to invalid syntax."
    ],
    correctOption: "The sum of all provided arguments.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::move' function in C++?",
    options: [
      "It casts an object to an rvalue reference, enabling move semantics.",
      "It is only applicable to STL containers.",
      "It guarantees exception safety.",
      "It physically moves the object to a new memory location."
    ],
    correctOption: "It casts an object to an rvalue reference, enabling move semantics.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::shared_ptr' in C++?",
    options: [
      "To prevent memory leaks in stack-allocated objects.",
      "To manage shared ownership of a dynamically allocated object.",
      "To provide a thread-safe pointer.",
      "To enforce exclusive ownership of a dynamically allocated object."
    ],
    correctOption: "To manage shared ownership of a dynamically allocated object.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::forward' function in C++?",
    options: [
      "To prevent argument modification.",
      "To convert an rvalue reference to an lvalue reference.",
      "To perfect-forward arguments, preserving their value category (lvalue/rvalue).",
      "To enforce move semantics on all arguments."
    ],
    correctOption: "To perfect-forward arguments, preserving their value category (lvalue/rvalue).",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::unique_ptr' in C++?",
    options: [
      "It cannot be used with custom deleters.",
      "It is slower than raw pointers due to reference counting.",
      "It enforces exclusive ownership of a dynamically allocated object.",
      "It allows shared ownership of a dynamically allocated object."
    ],
    correctOption: "It enforces exclusive ownership of a dynamically allocated object.",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following code snippet involving a shared_ptr and circular references?",
    options: [
      "Automatic cleanup of all objects.",
      "Runtime error due to null pointer dereference.",
      "Compilation error due to invalid pointer usage.",
      "Memory leak due to reference cycles."
    ],
    correctOption: "Memory leak due to reference cycles.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::weak_ptr' in C++?",
    options: [
      "It cannot be converted to a shared_ptr.",
      "It enforces exclusive ownership of a resource.",
      "It is faster than shared_ptr due to lack of atomic operations.",
      "It breaks circular references and does not contribute to reference counting."
    ],
    correctOption: "It breaks circular references and does not contribute to reference counting.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::function' template in C++?",
    options: [
      "To prevent function overloading.",
      "To replace virtual functions in inheritance hierarchies.",
      "To provide a general-purpose polymorphic function wrapper.",
      "To enforce compile-time evaluation of functions."
    ],
    correctOption: "To provide a general-purpose polymorphic function wrapper.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::bind' function in C++?",
    options: [
      "It enforces move semantics on all bound arguments.",
      "It creates a function object by binding arguments to a callable object.",
      "It cannot be used with member functions.",
      "It replaces the need for lambda functions."
    ],
    correctOption: "It creates a function object by binding arguments to a callable object.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a noexcept function that throws an exception?",
    options: [
      "The exception is caught and handled normally.",
      "std::terminate is called.",
      "Compilation error due to invalid noexcept usage.",
      "Undefined behavior."
    ],
    correctOption: "std::terminate is called.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'constexpr' keyword in C++?",
    options: [
      "It enforces runtime evaluation of expressions.",
      "It is only applicable to integer types.",
      "It indicates that a variable or function can be evaluated at compile-time.",
      "It prevents inlining of functions."
    ],
    correctOption: "It indicates that a variable or function can be evaluated at compile-time.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'alignas' specifier in C++?",
    options: [
      "To prevent memory fragmentation.",
      "To enforce stack alignment of local variables.",
      "To align memory allocations to page boundaries.",
      "To specify the alignment requirement of a type or object."
    ],
    correctOption: "To specify the alignment requirement of a type or object.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'thread_local' storage specifier in C++?",
    options: [
      "It is equivalent to 'static' but with thread safety.",
      "It prevents the variable from being shared between threads.",
      "It gives each thread its own copy of the variable.",
      "It enforces atomic access to the variable across threads."
    ],
    correctOption: "It gives each thread its own copy of the variable.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a union with a non-trivial member?",
    options: [
      "Undefined behavior due to active member violation.",
      "The last assigned member is preserved.",
      "Runtime error due to type mismatch.",
      "Compilation error due to invalid union usage."
    ],
    correctOption: "Undefined behavior due to active member violation.",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about the 'std::variant' in C++?",
    options: [
      "It is a type-safe union that holds one of several alternative types.",
      "It cannot be used with non-trivial types.",
      "It is equivalent to a void pointer with runtime type checking.",
      "It enforces dynamic allocation of its contained value."
    ],
    correctOption: "It is a type-safe union that holds one of several alternative types.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'std::any' class in C++?",
    options: [
      "To provide a base class for polymorphic types.",
      "To enforce compile-time type checking for all assignments.",
      "To replace the need for templates.",
      "To hold a single value of any type in a type-safe manner."
    ],
    correctOption: "To hold a single value of any type in a type-safe manner.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::optional' in C++?",
    options: [
      "It enforces dynamic allocation for the contained value.",
      "It is equivalent to a nullable pointer.",
      "It cannot be used with primitive types.",
      "It represents an optional value that may or may not be present."
    ],
    correctOption: "It represents an optional value that may or may not be present.",
    difficulty: "beginner"
  },
  {
    question: "What is the output of the following code snippet involving a structured binding declaration?",
    options: [
      "Undefined behavior.",
      "Compilation error due to invalid syntax.",
      "A runtime error due to type mismatch.",
      "The values of the tuple elements are unpacked into individual variables."
    ],
    correctOption: "The values of the tuple elements are unpacked into individual variables.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::string_view' in C++?",
    options: [
      "It cannot be used with string literals.",
      "It is equivalent to 'const std::string&' but with ownership.",
      "It provides a non-owning view of a string, reducing copies.",
      "It enforces null-termination of the underlying string."
    ],
    correctOption: "It provides a non-owning view of a string, reducing copies.",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the '[[nodiscard]]' attribute in C++?",
    options: [
      "To mark a function as deprecated.",
      "To warn if the return value of a function is ignored.",
      "To prevent a function from returning a value.",
      "To enforce compile-time evaluation of a function."
    ],
    correctOption: "To warn if the return value of a function is ignored.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the '[[likely]]' and '[[unlikely]]' attributes in C++?",
    options: [
      "They enforce runtime checks for branch conditions.",
      "They are only applicable to loop constructs.",
      "They prevent certain branches from being executed.",
      "They provide hints to the compiler about branch prediction."
    ],
    correctOption: "They provide hints to the compiler about branch prediction.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a coroutine in C++20?",
    options: [
      "The coroutine suspends and resumes execution asynchronously.",
      "Undefined behavior.",
      "Compilation error due to missing 'co_await' keyword.",
      "Runtime error due to stack overflow."
    ],
    correctOption: "The coroutine suspends and resumes execution asynchronously.",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about the 'consteval' keyword in C++20?",
    options: [
      "It is a synonym for 'constexpr' with no difference in behavior.",
      "It specifies that a function must be evaluated at compile-time.",
      "It enforces runtime evaluation of a function.",
      "It prevents a function from being inlined."
    ],
    correctOption: "It specifies that a function must be evaluated at compile-time.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::span' class in C++20?",
    options: [
      "To replace all uses of raw pointers and arrays.",
      "To provide a growable array-like container.",
      "To provide a bounds-safe view over a contiguous sequence of objects.",
      "To enforce compile-time size checking for arrays."
    ],
    correctOption: "To provide a bounds-safe view over a contiguous sequence of objects.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::format' library in C++20?",
    options: [
      "It cannot be used with user-defined types.",
      "It is a legacy feature deprecated in C++20.",
      "It enforces runtime parsing of format strings.",
      "It provides type-safe string formatting similar to Python's str.format."
    ],
    correctOption: "It provides type-safe string formatting similar to Python's str.format.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a three-way comparison operator (<=>)?",
    options: [
      "A boolean result (true/false).",
      "A comparison result indicating less, equal, or greater.",
      "Undefined behavior.",
      "Compilation error due to missing operator overload."
    ],
    correctOption: "A comparison result indicating less, equal, or greater.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::source_location' in C++20?",
    options: [
      "It is used for runtime stack tracing.",
      "It cannot be used in constexpr contexts.",
      "It replaces the preprocessor macros __FILE__ and __LINE__.",
      "It provides information about the source code location (file, line, etc.)."
    ],
    correctOption: "It provides information about the source code location (file, line, etc.).",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'std::jthread' class in C++20?",
    options: [
      "It is a thread with priority scheduling capabilities.",
      "It enforces compile-time thread creation.",
      "It is a joining thread that automatically joins on destruction.",
      "It cannot be used with lambdas."
    ],
    correctOption: "It is a joining thread that automatically joins on destruction.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::atomic_ref' in C++20?",
    options: [
      "It enforces lock-free operations on all platforms.",
      "It provides atomic operations on non-atomic objects.",
      "It is a deprecated feature replaced by 'std::atomic'.",
      "It cannot be used with floating-point types."
    ],
    correctOption: "It provides atomic operations on non-atomic objects.",
    difficulty: "intermediate"
  },
  {
    question: "What is the output of the following code snippet involving a 'std::latch' in C++20?",
    options: [
      "Undefined behavior.",
      "A runtime deadlock due to incorrect latch usage.",
      "The latch synchronizes threads until the counter reaches zero.",
      "Compilation error due to missing header."
    ],
    correctOption: "The latch synchronizes threads until the counter reaches zero.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::barrier' in C++20?",
    options: [
      "It is a deprecated feature replaced by 'std::latch'.",
      "It cannot be reused after all threads arrive.",
      "It enforces a fixed number of threads at compile-time.",
      "It synchronizes a group of threads, executing a completion function when all threads arrive."
    ],
    correctOption: "It synchronizes a group of threads, executing a completion function when all threads arrive.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::counting_semaphore' in C++20?",
    options: [
      "It cannot be used with 'std::jthread'.",
      "It enforces compile-time resource limits.",
      "It is a synchronization primitive for single-threaded contexts.",
      "It limits the number of threads accessing a resource simultaneously."
    ],
    correctOption: "It limits the number of threads accessing a resource simultaneously.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::stop_token' in C++20?",
    options: [
      "It cannot be used with 'std::jthread'.",
      "It provides a mechanism to request thread cancellation.",
      "It is a deprecated feature replaced by 'std::atomic_flag'.",
      "It enforces immediate thread termination."
    ],
    correctOption: "It provides a mechanism to request thread cancellation.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a 'std::generator' in C++23?",
    options: [
      "A runtime error due to infinite recursion.",
      "Undefined behavior.",
      "A sequence of values generated lazily.",
      "Compilation error due to missing C++23 support."
    ],
    correctOption: "A sequence of values generated lazily.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::expected' in C++23?",
    options: [
      "It represents either a value or an error, similar to 'std::variant' but for error handling.",
      "It is a deprecated feature replaced by 'std::optional'.",
      "It cannot be used with exception-based error handling.",
      "It enforces compile-time error checking."
    ],
    correctOption: "It represents either a value or an error, similar to 'std::variant' but for error handling.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::mdspan' in C++23?",
    options: [
      "It cannot be used with user-defined allocators.",
      "It is a deprecated feature replaced by 'std::span'.",
      "It enforces compile-time bounds checking.",
      "It provides a multi-dimensional view over contiguous data."
    ],
    correctOption: "It provides a multi-dimensional view over contiguous data.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::hive' in C++23?",
    options: [
      "It is a container that allows stable references even after insertions and deletions.",
      "It cannot be used with non-trivial types.",
      "It is a deprecated feature replaced by 'std::vector'.",
      "It enforces compile-time size limits."
    ],
    correctOption: "It is a container that allows stable references even after insertions and deletions.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a 'std::stacktrace' in C++23?",
    options: [
      "Undefined behavior.",
      "A snapshot of the current call stack.",
      "A runtime error due to stack overflow.",
      "Compilation error due to missing C++23 support."
    ],
    correctOption: "A snapshot of the current call stack.",
    difficulty: "advanced"
  },
  {
    question: "Which of the following is true about the 'std::byteswap' in C++23?",
    options: [
      "It enforces compile-time byte swapping.",
      "It cannot be used with floating-point types.",
      "It is a deprecated feature replaced by bit manipulation utilities.",
      "It reverses the byte order of an integer."
    ],
    correctOption: "It reverses the byte order of an integer.",
    difficulty: "intermediate"
  },
  {
    question: "What is the purpose of the 'std::is_scoped_enum' trait in C++23?",
    options: [
      "It cannot be used with unscoped enumerations.",
      "It is a deprecated feature replaced by 'std::is_enum'.",
      "To check if a type is a scoped enumeration.",
      "It enforces compile-time enum validation."
    ],
    correctOption: "To check if a type is a scoped enumeration.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::to_underlying' in C++23?",
    options: [
      "It converts an enum to its underlying type.",
      "It cannot be used with scoped enumerations.",
      "It is a deprecated feature replaced by 'static_cast'.",
      "It enforces runtime type checking."
    ],
    correctOption: "It converts an enum to its underlying type.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a 'std::move_only_function' in C++23?",
    options: [
      "Compilation error due to missing C++23 support.",
      "A runtime error due to invalid function invocation.",
      "A callable object that can only be moved, not copied.",
      "Undefined behavior."
    ],
    correctOption: "A callable object that can only be moved, not copied.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::forward_like' in C++23?",
    options: [
      "It cannot be used with rvalue references.",
      "It is a deprecated feature replaced by 'std::forward'.",
      "It enforces compile-time type deduction.",
      "It forwards an expression with the same value category as another expression."
    ],
    correctOption: "It forwards an expression with the same value category as another expression.",
    difficulty: "beginner"
  },
  {
    question: "What is the purpose of the 'std::unreachable' in C++23?",
    options: [
      "It is a deprecated feature replaced by 'assert(false)'.",
      "It cannot be used in constexpr contexts.",
      "It enforces runtime checks for unreachable code.",
      "To indicate unreachable code paths to the compiler."
    ],
    correctOption: "To indicate unreachable code paths to the compiler.",
    difficulty: "intermediate"
  },
  {
    question: "Which of the following is true about the 'std::optional' monadic operations in C++23?",
    options: [
      "They allow chaining operations on optional values without explicit checks.",
      "They enforce compile-time optional validation.",
      "They cannot be used with non-trivial types.",
      "They are deprecated features replaced by 'std::variant'."
    ],
    correctOption: "They allow chaining operations on optional values without explicit checks.",
    difficulty: "advanced"
  },
  {
    question: "What is the output of the following code snippet involving a 'std::span' in C++23?",
    options: [
      "A view over a contiguous sequence of elements.",
      "Undefined behavior.",
      "A runtime error due to invalid span usage.",
      "Compilation error due to missing C++23 support."
    ],
    correctOption: "A view over a contiguous sequence of elements.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::ranges' in C++23?",
    options: [
      "They are deprecated features replaced by 'std::vector'.",
      "They cannot be used with user-defined types.",
      "They enforce compile-time range validation.",
      "They provide a new way to work with ranges and algorithms in a more expressive manner."
    ],
    correctOption: "They provide a new way to work with ranges and algorithms in a more expressive manner.",
    difficulty: "advanced"
  },
  {
    question: "What is the purpose of the 'std::span' in C++23?",
    options: [
      "It enforces compile-time size limits.",
      "To provide a lightweight, non-owning view over a contiguous sequence of elements.",
      "It is a deprecated feature replaced by 'std::vector'.",
      "It cannot be used with non-trivial types."
    ],
    correctOption: "To provide a lightweight, non-owning view over a contiguous sequence of elements.",
    difficulty: "beginner"
  },
  {
    question: "Which of the following is true about the 'std::format' in C++23?",
    options: [
      "It is a deprecated feature replaced by 'std::stringstream'.",
      "It enforces compile-time format string validation.",
      "It provides a type-safe way to format strings, similar to Python's f-strings.",
      "It cannot be used with user-defined types."
    ],
    correctOption: "It provides a type-safe way to format strings, similar to Python's f-strings.",
    difficulty: "advanced"
  }
];